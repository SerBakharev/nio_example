Каналы и селекторы
Channel — это базовый интерфейс, который предоставляет API для чтения данных из разных источников и записи в них.
 Например, так можно работать с файлами, сокетами, буферами и прочим. В Java Channel используется неблокирующий ввод-вывод,
  который позволяет приложению продолжать работу, пока операция ввода-вывода не завершена.

Channel можно использовать для решения задач, связанных с вводом-выводом данных, например:

чтение и запись файлов: Channel позволяет работать с файлами эффективнее традиционных потоков ввода-вывода;
работа с сокетами: Channel можно использовать для чтения данных из сокетов и записи в них, что помогает реализовать сетевые приложения;
работа с буфером: Channel позволяет работать с буферами данных, что повышает эффективность операций ввода/вывода.
При работе с интерфейсами и классами, имплементирующими или наследующими интерфейс AutoСlosable,
 можно использовать конструкцию try-with-resources. Она предоставляет удобный способ автоматического закрытия ресурсов,
  открытых в блоке try, после завершения работы с ними или при возникновении исключения в блоке try. При необходимости
   вызова нескольких ресурсов их можно перечислять, разделяя точкой с запятой.

Реализуем класс FileCopySimpleExample — простой пример функции, копирующей объёмный файл из входящего канала в исходящий при помощи ByteBuffer.

Класс FileCopySimpleExample:

определяет путь до файлов;
открывает каналы для чтения и записи;
создаёт буфер объёмом в 1 024 байта;
записывает данные в целевой FileChannel.

Так мы быстро сделали копию объёмного файла, используя исключительно инструменты из пакета java.nio.

Передача данных не ограничивается локальной системой, так как NIO API позволяет передавать информацию через сетевое подключение.
 В качестве примера реализуем клиент-серверное соединение, используя имеющиеся базовые инструменты.

Проверьте, свободен ли порт 8088 на вашем ПК. Для этого запустите следующую команду:

в терминале Windows 10 — netstat -ano | findstr 8088;
в терминале Mac — lsof -i :8088;
в терминале Linux — netstat -tln | grep :8088.
Если результат запроса пустой, значит, порт не занят. Если порт занят, найдите другой, добавляя единицу,
 пока не увидите свободный. Например, можно попробовать 8089, 8090 и так далее.

 Создадим два класса.

 Серверный (NetworkServerExample) для приёма сообщения:

 создаёт серверный сокет-канал и привязывает его к порту 8088;
 ожидает подключение клиента;
 принимает сообщение от клиента;
 закрывает сокет-каналы.

 Клиентский (NetworkClientExample) для отправки сообщения:

 создаёт клиентский сокет-канал и подключается к серверу по адресу и порту;
 отправляет сообщение на сервер;
 закрывает сокет-канал.
 Первым запустите серверный класс и дождитесь сообщения: Server started on port 8088. Затем запустите клиентский.

 Вывод программы будет следующим:

 NetworkClientExample
 Connected to server
 Sent message to server: Hello, server!
 NetworkServerExample
 Server started on port 8088
 Client connected: /127.0.0.1:54763
 Received message from client: Hello, server!
 Так мы можем передавать данные по сети, используя только имеющийся функционал Java NIO.

В завершение изучения данного блока затронем тему селекторов.

Селекторы используются для одновременного обслуживания нескольких каналов ввода-вывода в одном потоке.
Это позволяет обрабатывать несколько соединений в одном потоке и может быть полезно для обработки большого количества
соединений или повышения производительности ввода-вывода.

Рассмотрим пример с сервером и тремя клиентами.

Создадим класс, имитирующий работу сервера SelectorServerExample:

создаёт селектор;
создаёт два серверных канала и регистрирует их в селекторе;
блокирует работу до поднятия каналов;
получает ключи для каналов;
проверяет подключение от клиентов;
считывает данные из канала в буфер и выводит их в консоль.

Реализуем и запустим после запуска сервера три клиентских класса SelectorClientExample:

создают канал соединения с сервером;
считывают пользовательский ввод;
закрывают канал;
два клиента обращаются по одному порту.

С помощью селектора можно регистрировать каналы, которые могут быть готовы к операциям (OP) чтения (OP_READ), записи (OP_WRITE),
подключения (OP_CONNECT) или принятия нового соединения (OP_ACCEPT). Селектор также позволяет определять, какие каналы готовы
к обработке ввода-вывода, и в соответствии с этим обрабатывать их. Это сильно упрощает код для работы с несколькими каналами
ввода-вывода и устраняет необходимость использования нескольких потоков для обработки каждого соединения.

Селекторы также могут использоваться для реализации асинхронного ввода-вывода, когда приложение может продолжать работу,
в то время как данные считываются или записываются в фоновом режиме. Это может улучшить производительность и отзывчивость приложения.

Выводы
В этом материале вы познакомились с Java NIO API, изучили его основные компоненты и рассмотрели примеры их использования.
Знание механизмов работы с потоками ввода-вывода помогут вам создавать гибкие и высокопроизводительные приложения.